## 5.6 try语句块和异常处理
C++语言中，异常处理包括：
- **throw表达式**，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw**引发**了异常。
- **try语句块**，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个**catch子句**结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句”处理“异常，所以它们也被称为**异常处理代码**。
- 一套**异常类**，用于在throw表达式和相关的catch子句之间传递异常的具体信息。
  
### 5.6.1 throw表达式
程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面紧跟一个分号，从而构成一条表达式语句。

举个简单的例子，回忆1.5.2节把两个Sales_item对象相加的程序。这个程序检查它读入的记录是否是关于同一种书籍的，如果不是，输出一条信息然后退出。
```
Sales_item item1, item2;
cin >> item1 >> item2;
//首先检查item1和item2是否表示同一种书籍
if (item1.isbn() == item2.isbn())
{
    cout << item1 + item2 << endl;
    return 0;
}
else 
{
    cerr << "Data must refer to same ISBN" << endl;
    return -1;  //表示失败
}
```
在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序使得见检查完成后不再输出一条信息，而是抛出一个异常：
```
//首先检查两条数据是否是同一种书籍的
if (item1.isbn() != item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
//如果程序执行到了这里，表示两个ISBN是相同的
cout << item1 + item2 << endl;
```
在这段代码中，如果ISBN不一样就抛出一个异常，该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。

类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。关于标准库异常类型更多的知识将在5.6.3节介绍。我们必须初始化runtime_error的对象，方式是给它提供一个string对象或者一个C风格的字符串，这个字符串中有一些关于异常的赋值信息。

### 5.6.2 try语句块
try语句块的通用语法形式是
```
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} // ...
```
try语句块的一开始是关键字try，随后紧跟着一个块，这个块就像大多数时候那样是花括号括起来的语句序列。

跟在try块之后的是一个或多个catch子句。catch子句包括三部分：关键字catch、括号内一个（可能未命名的）对象的声明（称作**异常处理**）以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。

try语句块中的program-statements组成程序的正常逻辑，像其他任何块一样，program-statements可以有包括声明在内的任意C++语句。一如往常，try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。

### 编写处理代码
在之前的例子里，我们使用了一个throw表达式以避免把两个代表不同书籍的Sales_item相加。我们假设执行Sales_item对象加法的代码是与用户交互的代码分离开来的。其中与用户交互的代码负责处理发生的异常，它的形式可能如下所示：
```
while (cin >> item1 >> item2)
{
    try {
        // 执行添加两个Sales_item对象的代码
        // 如果添加失败，代码抛出一个runtime_error异常
    }
    catch (runtime_error err)
    {
        //提醒用户两个ISBN必须一致，询问是否重新输入
        cout << err.what()
             << "\nTyr Again? Enter y or n" << endl;
        char c;
        cin >> c;
        if(!cin || c == 'n')
            break;  //跳出while循环
    }
}
```
程序本来要执行的任务出现在try语句块中，这是因为这段代码可能会抛出一个runtime_error类型的异常。

try语句块对应一个catch子句，该子句负责处理类型为runtime_error的异常。如果try语句块的代码抛出了runtime_error异常，接下来执行catch块内的语句。在我们书写的catch子句中，输出一段提示信息要求用户指定程序是否继续。如果用户输入'n'，执行break语句并退出while循环；否则，直接执行while循环的右侧花括号，意味着程序控制权条回到while条件部分准备下一次迭代。

给用户的提示信息中输出了err.what()的返回值。我们知道err的类型是runtime_error，因此能推断what是runtime_error类的一个成员函数。每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串（即const char*）。其中，runtime_error的what成员返回的是初始化一个具体对象时所用的string对象的副本。如果上一节编写的代码抛出的代码抛出异常，则本节的catch子句输出
```
Data must refer to same ISBN
Try Again? Enter y or n
```
### 函数在寻找处理代码的过程中退出
在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。

寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，机组搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。

如果最终还是没找到任何匹配的catch子句，程序转到名为**terminate**的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。

对于那些没有任何try语句块定义的异常，也按照类似的方式处理：毕竟，没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。

要好好理解这句话：异常中断了程序的正常流程。异常发生时，调用者请求的一部分计算可能已经完成了，另一部分尚未完成。通常情况下，略过部分程序意味着某些对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正常释放，等等。那些在异常发生期间正确执行了”清理“工作的程序被称作**异常安全**的代码。然而经验表明，编写异常安全的代码非常困难，这部分知识也（远远）超出了本书的范围。

### 5.6.3 标准异常
C++标准库定义了一组类，用于报告标准库遇到的问题。这些异常类也可以在用户编写的程序中使用，它们的分别定义在4个头文件中：
- exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。
- stdexcept头文件定义了几种常用的异常类，详细信息在表5.1中列出。
- new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节详细介绍。
- type_info头文件定义了bad_cast异常类型，这种类型将在19.2节详细介绍。
  
#### 表5.1：<stdexcept>定义的异常类
异常类|含义
:--|:--
exception|最常见的问题
runtime_error|只有在运行时才能检测出问题
range_error|运行时错误：生成的结果超出了有意义的值域范围
overflow_error|运行时错误：计算上溢
underflow_error|运行时错误：计算下溢
logic_error|程序逻辑错误
domain_error|逻辑错误：参数对应的结果值不存在
invalid_argument|逻辑错误：无效参数
length_error|逻辑错误：试图创建一个超出该类型最大长度的对象
out_of_range|逻辑错误：使用一个超出有效范围的值

标准库异常类只定义了几种运算，包括创建或拷贝异常类型的对象，以及为异常类型的对象赋值。

我们只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。

其他异常类型的行为恰好相反：应该使用string对象或者C风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。

异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char*。该字符串的目的是提供关于异常的一些文本信息。

what函数返回的C风格字符串的内容与异常对象的类型有关。如果异常类型有一个字符串初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回的内容由编译器决定。


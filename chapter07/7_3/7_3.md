## 7.3 类的其他特性
在本节中我们将继续介绍Sales_data没有体现出来的一些类的特性。这些特性包括：类型成员、类的成员的类内初始值、可变数据成员、内联成员函数、从成员函数返回*this、关于如何定义并使用类类型及友元类的更多知识。

### 7.3.1 类成员再探
为了展示这写新特性，我们需要定义一对相互关联的类，它们分别是Screen和Window_mgr。

#### 定义一个类型成员
Screen表示显示器中的窗口。每个Screen包含一个用于保存Screen内容的string成员和三个string::size_type类型的成员，它们分别表示光标的位置以及屏幕的高和宽。

除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者pirvate中的一种：
```
class Screen {
public:
    typedef std::string::size_type pos;
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
```
我们在Screen的public部分定义了pos，这样用户就可以使用这个名字。Screen的用户不应该知道Screen使用了一个string对象来存放它的数据，因此通过把pos定义在public成员可以隐藏Screen实现的细节。

关于pos的声明有两点需要注意。首先，我们使用了typedef，也可以等价地使用类型别名：
```
class Screen {
public:
    //使用类型别名等价地声明一个类型名字
    using pos = std::string::size_type;
    //其他成员与之前的版本一致
};
```
其次，用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别，具体原因将在7.4.1节解释。因此类型成员通常出现在类开始的地方。

#### Screen类的成员函数
要是我们的类更加实用，还需要添加一个构造函数令用户能够定义屏幕的尺寸和内容，以及其他两个成员，分别负责移动光标和读取给定位置的字符：
```
class Screen {
public:
    typedef std::string::size_type pose;
    Screen() = default; //因为Screen有另一个构造函数
                        //所以本函数是必需的
    //cursor被其类内初始值初始化为0
    Screen(pos ht, pos wd, char c) : height(ht), widht(wd), contents(ht * wd, c) { }
    char get() const                        //读取光标 
            { return contents[cursor]; }   //隐式内联
    inline char get(pos ht, pos wd) const;  //显式内联
    Screen &move(pos r, pos c);             //能在之后被设为内联
pirvate:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
```
因为我们已经提供了一个构造函数，所以编译器将不会自动生成默认的构造函数。如果我们的类需要默认构造函数，必须显式地把它声明出来。在此例中，我们使用=default告诉编译器为我们合成默认的构造函数。

需要指出的是，第二个构造函数为cursor成员隐式地使用了类内初始值。如果类中不存在cursor的类内初始值，我们就需要像其他成员一样显示地初始化cursor了。

#### 令成员作为内联函数
在类中，常有一些规模较小的函数适合于被声明成内联函数。如我们之前所见的，定义在类内部的成员函数是自动inline的。因此，Screen的构造函数和返回光标所指字符的get函数默认是inline函数。

我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：
inline                                  //可以在函数的定义处指定inline
Screen &Screen::move(pos r, pos c)
{
    pos row = r * width;                //计算行的位置
    cursor = row + c;                   //在行内将光标移动到指定的列
    return *this;                       //以左值的形式返回对象
}
char Screen::get(pos r, pos c) const    //在类的内部声明成inline
{
    pos row = r * width;                //计算行的位置
    return contents[row + c];           //返回给定列的字符
}
虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过，最好只在类外部定义的地方说明inline，这样可以使类更容易理解。

和我们在头文件中定义inline函数的原因一样，inline成员函数也应该于相应的类定义在同一个头文件中。

#### 重载成员函数
和非成员函数一样，成员函数也可以被重载，只要函数之间在参数的数量和/或类型上有所区别就行。成员函数的函数匹配过程同样与非成员函数非常类似。

举个例子，我们的Screen类定义了两个版本的get函数，一个版本返回光标当前位置的字符；另一个版本返回由行号和列号确定的位置的字符。编译器根据实参的数量来决定运行哪个版本的函数：
```
Screen myscreen;
char ch = myscreen.get();       //调用Screen::get()
ch = myscreen.get(0, 0);        //调用Screen::get(pos, pos)
```
#### 可变数据成员
有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使使在一个const成员函数内。可以通过在变量的声明中假如mutable关键字做到这一点。

一个**可变数据成员**永远不是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值。举个例子，我们将给Screen添加一个名为access_ctr的可变成员，通过它我们可以追踪每个Screen的成员函数被调用了多少次：
```
class Screen {
public:
    void some_member() const;
private:
    mutable size_t access_ctr;      //即使在一个const对象内也能被修改
    //和其他成员与之前的版本一致
};
void Screen::some_member() const
{
    ++access_ctr;       //保存一个计数值，用于记录成员函数被调用的次数
    // 该成员需要完成的其他工作
}
```
尽管some_member是一个const成员函数，它仍然能够改变access_ctr的值。该成员是个可变成员，因此任何成员函数，包括const函数在内都能改变它的值。

#### 类数据成员的初始值
在定义好Screen类之后，我们将继续定义一个窗口管理类并用它表示显示器上的一组Screen。这个类将包含一个Screen类型的vector，每个元素表示一个特定的Screen。默认情况下，我们希望Window_mgr类开始时总是拥有一个默认初始化的Screen。在C++11新标准中，最好的方式就是把这个默认值声明成一个类内初始值：
```
class Window_mgr {
private:
    //这个Window_mgr追踪的Screen
    //默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen
    std::vector<Screen> screens{Screen(24, 80, ' ')};
};
```
当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。在此例中，我们使用一个单独的元素值对vector成员执行了列表初始化，这个Screen的值被传递给vector< Screen>的构造函数，从而创建了一个单元素的vector对象。具体地说，Screen的构造函数接受两个尺寸参数和一个字符值，创建了一个给定大小的空白屏幕对象。

如我们之前所知的，类内初始值必须使用=的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。

当我们提供一个类内初始值时，必须以符号=或者花括号表示。


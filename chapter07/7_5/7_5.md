## 7.5 构造函数再探
### 7.5.1 构造函数初始值列表
如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。例如：
```
// Sales_data构造函数的一种写法，虽然合法但比较草率：没有使用构造函数初始值
Sales_data::Sales_data(const string &s, unsigned cnt, double price)
{
    bookNo = s;
    units_sold = cnt;
    revenue = cnt * prive;
}
```
这段代码和我们在237页的原始定义效果是相同的：当构造函数完成后，数据成员的值相同。区别是原来的版本初始化了它的数据成员，而这个版本是对数据成员执行了赋值操作。这一区别到底会有什么深层次的影响完全依赖于数据成员的类型。

#### 构造函数的初始值有时必不可少
有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者是引用的话，必须将起初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。例如：
```
class ConstRef {
public:
    ConstRef(int ii);
private:
    int i;
    const int ci;
    int &ri;
};
```
和其他常量对象或者引用一样，成员ci和ri都必须初始化。因此，如果我们没有为它们提供构造函数初始值的话将引发错误：
```
// 错误：ci和ri必须初始化
ConsRef::ConstRef(int ii)
{   //赋值：
    i = ii;                     //正确
    ci = ii;                    //错误：不能给const赋值
    ri = i;                     //错误：ri没被初始化
}
```
随着构造函数一开始执行，初始化就完成了。我们初始化const或者引用类型的数据成员唯一机会就是通过构造函数初始值，因此该构造函数的正确形式应该是：
```
// 正确：显式地初始化引用和const成员
ConstRef::ConstRef(int ii) : i(ii), ci(ii), ri(i) { }
```

如果成员是const、引用，或者属于某种为提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。

#### 建议：使用构造函数初始值

在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。

除了效率问题外更重要的是，一些数据成员必须被初始化。

#### 成员初始化的顺序
构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。

成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。

一般来说，初始化的顺序没什么特别要求。不过如果是一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了。

举个例子，考虑下面这个类：
```
class X {
    int i;
    int j;
public:
    // 未定义的：i在j之前被初始化
    X(int val) : j(val), i(j) { }
};
```
在此例中，从构造函数初始值的形式上来看仿佛先用val初始化了j，然后再用j初始化i。实际上，i先被初始化，因此这个初始值的效果是试图使用未定义的值j初始化i！

最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。

#### 默认实参和构造函数
Sales_data默认构造函数的行为与只接受一个string实参的构造函数差不多。唯一的区别是接受string实参的构造函数使用这个实参初始化bookNo，而默认构造函数（隐式地）使用string的默认构造函数初始化bookNo。我们可以把它们重写成一个使用默认实参的构造函数：
```
class Sales_data {
public:
    // 定义默认构造函数，令其与只接受一个string实参的构造函数功能相同
    Sales_data(std::string s = "") : bookNo(s) { }
    // 其他构造函数与之前一致
    Sales_data(std::string s, unsigned cnt, double rev) : 
        bookNo(s), units_sold(cnt), revenue(rev*cnt) { }
    Sales_data(std::istream &is) { read(is, *this); }
    // 其他成员与之前的版本一致
};
```
在上面这段函数中，类的接口与第237页的代码是一样的。当没有给定实参，或者给定了一个string实参时，两个版本的类创建了相同的对象。因为我们不提供实参也能调用上述的构造函数，所以该构造函数实际上为我们的类提供了默认构造函数。

如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

使得注意的是，我们不应该为Sales_data接受三个实参的构造函数提供默认值。因为如果用户为售出书籍的数量提供了一个非零的值，则我们就会期望用户同时提供这些书籍的售出价格。

### 7.5.2 委托构造函数
C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的**委托构造函数**。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它自己的一些（或者全部）职责委托给了其他构造函数。

和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个为一个的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。

举个例子，我们使用委托构造函数重写Sales_data类，重写后的形式如下所示：
```
class Sales_data {
public:
    // 非委托构造函数使用对应的实参初始化成员
    Sales_data(std::string s, unsigned cnt, double price): bookNo(s), units_sold(cnt), reveneu(cnt*price) { }
    // 其余构造函数全部委托给另一个构造函数
    Sales_data() : Sales_data("", 0, 0) {}
    Sales_data(std::string s) : Sales_data(s, 0, 0) {}
    Sales_data(std::istream &is) : Sales_data()
                                    { read(is, *this); }
    // 其他成员与之前的版本一致
};
```
在这个Sales_data类中，除了一个构造函数外其他的都委托了它们的工作。第一个构造函数接受三个实参，使用这些实参初始化数据成员，然后结束工作。我们定义默认构造函数令其使用三参数的构造函数完成初始化过程，它也无须执行其他任务，这一点从空的构造函数体能看得出来。接受一个string的构造函数同样委托给了三参数的版本。

接受istream&的构造函数也是委托构造函数，它委托了默认构造函数，默认构造函数又接着委托给三参数构造函数。当这些受委托的构造函数执行完后，接着执行istream&构造函数体的内容。它的构造函数调用read函数读取给定的istream。

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。在Sales_data类中，受委托的构造函数恰好是空的。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交给委托者的函数体。





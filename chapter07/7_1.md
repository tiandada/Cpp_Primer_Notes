类的基本思想是**数据抽象**和**封装**。数据抽象是一种依赖于**接口**和**实现**分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

类要想实现数据抽象和封装，需要首先定义一个**抽象数据类型**。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。

## 7.1 定义抽象数据类型
### 7.1.1 设计Sales_data类
Sales_data的接口应该包含以下操作：
- 一个isbn成员函数，用于返回对象的ISBN编号
- 一个combine成员函数，用于将一个Sales_data对象的加法
- 一个名为add的函数，执行两个Sales_data对象的加法
- 一个read函数，将数据从istream读入到Sales_data对象中
- 一个print函数，将Sales_data对象的值输出到ostream

#### 使用改进的Sales_data类
在考虑如何实现我们的类之前，首先来看看应该如何使用上面的这些接口函数。举个例子：
```
Sales_data total;                       //保存当前求和结果的变量
if (read(cin, total))                   //读入第一笔交易
{
    Sales_data trans;                   //保存下一条交易数据的变量
    while(read(cin, trans))             //读入剩余的交易
    {
        if (total.isbn() == trans.isbn())   //检查isbn
            total.combine(trans);       //更新变量total当前的值
        else
        {
            print(cout, total) << endl;     //输出结果
            total = trans;                  //处理下一本书
        }
    }
    print(cout, total) << endl;             //输出最后一条交易
}
else                                        //没有输入任何信息
{
    cerr << "No data?!" << endl;            //通知用户
}
```

### 7.1.2 定义改进的Sales_data类
改进之后的类的数据成员将与2.6.1节定义的版本保持一致，它们包括：bookNo，string类型，表示ISBN编号；units_sold，unsigned类型，表示某书的销量；以及revenue，double类型，表示这本书的总销售收入。

如前所述，我们的类将包含两个成员函数：combine和isbn。此外，我们还将赋予Sales_data另一个成员函数用于返回售出书籍的平均价格，这个函数被命名为avg_price。因为avg_price的目的并非通用，所以它应该属于类的实现的一部分，而非接口的一部分。

定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，例如add、read和print等，它们的定义和声明都可以在类的外部。

由此可知，改进的Sales_data类应该如下所示：
```
struct Sales_data
{
    // 新成员：关于Sales_data对象的操作
    std::string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_price() const;
    // 数据成员和2.6.1节相比没有改变
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
// Sales_data的非成员接口函数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::string&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
```
定义在类内部的函数是隐式的inline函数。

#### 定义成员函数
尽管所有成员都必须在类的内部声明，但是成员函数可以定义在类内也可以定义在类外。对于Sales_data类来说，isbn函数定义在了类内，而combine和avg_price定义在了类外。

我们首先介绍isbn函数，它的参数列表为空，返回值是一个string对象：
```
std::string isbn() const { return bookNo; }
```
和其他函数一样，成员函数也是一个块。在此例中，块只有一条return语句，用于返回Sales_data对象的bookNo数据成员。关于isbn函数由一件有意思的事情是：它是如何获得bookNo成员所依赖的对象的呢？

#### 引入this
让我们再一次观察对isbn成员函数的调用：
```
total.isbn()
```
在这里，我们使用了点运算符来访问total对象的isbn成员，然后调用它。

7.6节将介绍一种例外的形式，当我们调用成员函数时，实际上是在替某个对象调用它。如果isbn指向Sales_data的成员，则它隐式地指向调用该函数的对象的成员。在上面所示的调用中，当isbn返回bookNo时，实际上它隐式地返回total.bookNo。

成员函数通过一个名为**this**的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如，如果调用
```
total.isbn()
```
则编译器负责把total的地址传递给isbn的隐式形参this，可以等价地认为编译器将该调用重写成了如下的形式：
```
//伪代码，用于说明调用成员函数的实际执行过程
Sales_data::isbn(&total)
```
其中，调用Sales_data的isbn成员传入了total的地址。

在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看做this的隐式引用，也就是说，当isbn使用bookNo时，它隐式地使用this指向的成员，就像我们书写了this->bookNo一样。

对于我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或变量的行为都是非法的。我们可以在成员函数体内部使用this，因此尽管没有必要，但我们还是能把isbn定义成如下的形式：
```
std::string isbn() const { return this->bookNo; }
```
因为this的目的总是指向“这个”对象，所以this是一个常量指针，我们不允许改变this中保存的地址。

#### 引入const函数
isbn函数的另一个关键之处是紧随着参数列表之后的const关键字，这里const的作用是修改隐式this指针的类型。

默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales_data成员函数中，this的类型是Sales_data *const。尽管this是隐式的，但它仍然需要遵循初始化规则，意味着（在默认情况下）我们不能把this绑定到要给常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。

如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data *const。毕竟，在isbn的函数体内不会改变this所指的对象。所以把this设置为指向常量的指针有助于提供函数的灵活性。

然而，this是隐式的并且不会出现在参数列表中，所以在哪儿将this声明成指向常量的指针就成为我们必须面对的问题。C++语言的做法是允许把const关键字放在成员参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称为**常量成员函数**。

可以把isbn的函数体想象成如下的形式：
```
// 伪代码，说明隐式的this指针是如何使用的
// 下面的代码是非法的：因为我们不能显式地定义自己的this指针
// 谨记此处的this是一个指向常量的指针，因为isbn是一个常量成员
std::string Sales_data::isbn(const Sales_dat *const this)
{ return this->isbn; }
```
因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，isbn可以读取调用它的对象的数据成员，但是不能写入新值。

常量对象，以及常量对象的引用或指针都只能调用常量成员函数。



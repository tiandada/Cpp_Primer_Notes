### 2.3 复合类型
C++有几种复合类型，本章将介绍其中的两种：引用和指针。
### 2.3.1 引用
**引用**为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：
```
int ival = 1024;
int &refVal = ival;		//refVal 指向ival(是ival的另一个名字)
int &refVal2;			//报错：引用必须被初始化
```
一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
**引用即别名**
引用并非对象，相反的，它只是为一个已经存在的对象所起的另外的一个名字。
**引用的定义**
允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&开头:
```
int i = 1024, i2 = 2048;	//i和i2都是int
int &i = i, r2 = i2;		//r是一个引用，与i绑定在一起，r2是int
int i3 - 1024, &ri = i3;	//i3是int，ri是一个引用，与i3绑定在一起
int &r3 = i3, &r4 = i2;		//r3和r4都是引用
```
除了2.4.1节和15.2.3节将要介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。
```
int &refVal4 = 10;		//错误：引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval;	//错误：此处引用类型的初始值必须是int型对象
```
### 2.3.2 指针
**指针**是＂指向（point to）＂另外一种类型的符合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点句号。
1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

因为在生命语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

### 指针值
指针的值（即地址）应属下列4种状态之一：
1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针，也就是上述情况之外的其他值。

### 空指针
**空指针**（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：
```
int *p1 = nullptr;		// 等价于int *p1 = 0;
int *p2 = 0;			// 直接将p2初始化为字面量0
// 需要首先#include cstdlib
int *p3 = NULL;			// 等价于int *p3 = 0;
```
得到空指针最直接的办法就是用字面值**nullptr**来初始化指针，这也是C++11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。

在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。



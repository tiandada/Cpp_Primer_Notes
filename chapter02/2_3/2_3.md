### 2.3 复合类型
C++有几种复合类型，本章将介绍其中的两种：引用和指针。
### 2.3.1 引用
**引用**为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：
```
int ival = 1024;
int &refVal = ival;		//refVal 指向ival(是ival的另一个名字)
int &refVal2;			//报错：引用必须被初始化
```
一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
**引用即别名**
引用并非对象，相反的，它只是为一个已经存在的对象所起的另外的一个名字。
**引用的定义**
允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&开头:
```
int i = 1024, i2 = 2048;	//i和i2都是int
int &i = i, r2 = i2;		//r是一个引用，与i绑定在一起，r2是int
int i3 - 1024, &ri = i3;	//i3是int，ri是一个引用，与i3绑定在一起
int &r3 = i3, &r4 = i2;		//r3和r4都是引用
```
除了2.4.1节和15.2.3节将要介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。
```
int &refVal4 = 10;		//错误：引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval;	//错误：此处引用类型的初始值必须是int型对象
```
### 2.3.2 指针
**指针**是＂指向（point to）＂另外一种类型的符合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。
1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

因为在生命语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

### 获取对象的地址
指针存放某个对象的地址，要获取该地址，需要使用**取地址符**(操作符&):
```
int ival = 42;
int *p = &ival;     //p存放变量ival的地址，或者说p是指向变量ival的指针
```
第二条语句把p定义为一个指向int的指针，随后初始化p令其指向名为ival的int对象。
因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

```
double dval;
double *pd = &dval;     //正确：初始值是double型对象的地址
double *pd2 = pd;       //正确：初始值是指向double对象的指针

int *pi = pd;           //错误：指针pi的类型和pd的类型不匹配
pi = &dval;             //错误：试图把double型对象的地址赋给int型指针
```
因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

### 指针值
指针的值（即地址）应属下列4种状态之一：
1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针，也就是上述情况之外的其他值。

试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。

尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，多以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。

### 利用指针访问对象
如果指针指向了一个对象，则允许使用解引用符（操作符*）来访问该对象：
```
int ival = 42;
int *p = &ival;     //p存放着变量ival的地址，或者说p是指向变量ival的指针
cout << *p;         //由符号*得到指针p所指的对象，输出42
```
对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：
```
*p = 0;             //由符号*得到指针P所指的对象，即可经由p为变量ival赋值
cout << *p;         //输出0
```
如上述程序所示，为*p赋值实际上是为p所指的对象赋值。

解引用操作仅适用于那些确实指向了某个对象的有效指针。

### 空指针
**空指针**（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：
```
int *p1 = nullptr;		// 等价于int *p1 = 0;
int *p2 = 0;			// 直接将p2初始化为字面量0
// 需要首先#include cstdlib
int *p3 = NULL;			// 等价于int *p3 = 0;
```
得到空指针最直接的办法就是用字面值**nullptr**来初始化指针，这也是C++11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。

在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。

把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。
```
int zero = 0;
pi = zero;      //错误：不能把int变量直接赋给指针
```

### 建议：初始化所有指针
建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。

###　赋值和指针
指针和引用都能提供对其它对象的间接访问，然而再具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

指针和它存放的地址之间就没有这种限制了。和其他任何变量（只要不是引用）一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象：
```
int i = 42;
int *pi = 0;        //pi被初始化，但没有指向任何对象
int *pi2 = &i;      //pi2被初始化，存有i的地址
int *pi3;           //如果pi3定义与块内，则pi3的值是无法确定的

pi3 = pi2;          //pi3和pi2指向同一个对象i
pi2 = 0;            //现在pi2不指向任何对象le
```

有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象。当写出如下语句时，
```
pi = &ival;         //pi的值被改变，现在pi指向了ival
```
意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。相反的，如果写出如下语句，
```
*pi = 0;            //ival的值被改变，指针pi并没有改变
```
则*pi（也就是指针pi指向的那个对象）发生改变。

###　其他指针操作
只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件（参见2.1.1节，第32页）遵循的规则类似，如果指针的值是0，条件取false:
```
int ival = 1024;
int *pi = 0;        //pi合法，是一个空指针
int *pi2 = &ival    //pi2是一个合法的指针，存放着ival的地址
if(pi)              //pi的值是0，因此条件的值是false
    // ...
if(pi2)             //pi2指向ival，因此它的值不是0，条件的值是true
    // ...          
```

任何非0指针对应的条件值都是true。

对于两个类型相同的合法指针，可以用相等操作符（==）或不相等操作符（!=）来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等；反之它们不相等。这里两个指针存放的地址值相同（两个指针相等）有三种可能：它们都为空、都指向同一个对象，或者都指向了同一个对象的下一个地址。

需要注意的是，一个指针指向某个对象，同时另一个指针指向另外对象的下一个地址，此时也有可能出现这两个指针值相同的情况，即指针相等。

因为上述操作要用到指针的值，所以不论是作为条件出现还是参与比较运算，都必须使用合法指针，使用非法指针作为条件或进行比较都会引发不可预计的后果。

3.5.3节(第105也)将介绍更多关于指针的操作。

### void* 指针
void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：
```
double obj = 3.14, *pd = &obj;  //正确：void*能存放任意类型对象的地址
void *pv = &obj;            //obj可以是任意类型的对象
pv = pd;                    //pv可以存放任意类型的指针
```

利用void*指针能做的事比较有限：拿它和别的指针比较
作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void\*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

概括说来，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象，关于这点将再19.1.1节（第726页）有更详细的介绍，4.11.3节（第144页）将讲述获取void\*指针所存地址的方法。


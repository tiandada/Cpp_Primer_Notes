## 处理类型
### 2.5.1 类型别名
**类型别名**是一个名字，它是某种类型的同义词。使用类型别名由很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用给类型的真实目的。

有两种方法可用于定义类型别名。传统的方法是使用关键字typedef：
```
typedef double wages;       //wages是double的同义词
typedef wages base, *p;     //base是double的同义词，p是double*的同义词
```
其中，关键字typedef作为声明语句中的基本数据类型的一部分出现。含有typedef的声明语句定义的不再是变量而是类型别名。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本类型构造出复合类型来。

新标准规定了了一种新的方法，使用**别名声明**来定义类型的别名：
```
using SI = Sales_item;      //SI是Sales_item的同义词
```
这种方法用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。

类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：
```
wages hourly, weekly;           //等价于double hourly、weekly;
SI item;                        //等价于Sales_item item
```
### 指针、常量和类型别名
如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型char*的别名：
```
typedef char *pstring;
const pstring cstr = 0;         //cstr是指向char的常量指针
const pstring *ps;              //ps是一个指针。它的对象是指向char的常量指针
```
上述两条声明语句的基本数据类型都是const pstring，和过去一样，const是对给定类型的修饰。pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针。

遇到一条使用了类型别名的声明语句时，人们往往会错误地把类型别名替换成他本来的样子，以理解改语句的含义：
```
const char *cstr = 0;           //是对const pstring cstr的错误理解
```
再强调一遍：这种理解是错误的。声明语句中用到pstring时，其基本数据类型是指针。可是用char*重写了声明语句后，数据类型就变成了char，\*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

###　2.5.2 auto类型说明符
编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了**auto**类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值：
```
//由val1和val2相加的结果可以推断出item的类型
auto item = val1 + val2;        //item的初始化为val1和val2相加的结果
```
此处编译器将根据val1和val2相加的结果来推断item的类型。如果val1和val2是类Sales_item的对象，则item的类型就是Sales_item；如果这两个变量的类型是double，则item的类型就是double，以此类推。

使用auto也能在一条语句中声明多个变量。因为一条声明语句只能由一个基本数据类型，所以改语句中所有变量的初始基本数据类型都必须一样：
```
auto i = 0, *p = &i;        //正确：i是整数、p是整型指针
auto sz = 0, pi = 3.14;     //错误：sz和pi的类型不一致
```

### 复合类型、常量和auto
编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。

首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：
```
int i = 0, &r = i;
auto a = r;             //a是一个整数（r是i的别名，而i是一个整数）
```
其次，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：
```
const int ci = i, &cr = ci;
auto b = ci;        //b是一个整数（ci的顶层const特性被忽略掉了）
auto c = cr;        //c是一个整数（cr是ci的别名，ci本身是一个顶层const）
auto d = &i;        //d是一个整型指针（整数的地址就是指向整数的指针）
auto e = &ci;       //e是一个指向整数常量的指针（对常量对象取地址是一种底层const）
```
如果希望推断出的auto类型是一个顶层const，需要明确指出：
```
const auto f = ci;      //ci的推演类型是int，f是const int
```
还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：
```
auto &g = ci;           //g是一个整型常量引用，绑定到ci
auto &h = 42;           //错误：不能为非常量引用绑定字面值
const auto &j = 42;     //正确：可以为常量引用绑定字面值
```
设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的变量就不是顶层常量了。

要在一条语句中定义多个变量，切记，符号&和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一类型：
```
auto k = ci, &l = i;        //k是整数，l是整数引用
auto &m = ci, *p = &ci;     //m是对整型常量的引用，p是指向整型常量的指针
//错误：i的类型是int而&ci的类型是const int
auto &n = i, *p2 = &ci; 
```

### 2.5.3 decltype类型指示符
有时会遇到这种情况：希望从表达式的类型推断出要定义的变脸的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符**decltype**，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：
```
decltype(f()) sum = x;      //sum的类型就是函数f的返回类型
```
编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如f被调用的话将会返回的那个类型。

decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：
```
const int ci = 0, &cj = ci;
decltype(ci) x = 0;             //x的类型是const int
decltype(cj) y = x;             //y的类型是const int&, y绑定到变量x
decltype(cj) z;                 //错误：z是一个引用，必须初始化
```
因为cj是一个引用，decltype(cj)的结果就是引用类型，因此作为引用的z必须被初始化。

需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。

### decltype和引用
如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如4.1.1节将要介绍的，有些表达式将向decltype返回一个引用类型。一般来说这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值：
```
//decltype的结果可以是引用类型
int i = 41, *p = &i, &r = i;
decltype(r + 0) b;          //正确：加法的结果是int，因此b是一个（未初始化的）int
decltype(*p) c;             //错误：c是int&，必须初始化
```
因为r是一个引用，因此decltype(r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。

另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype(*p)的结果类型就是int&，而非int。

decltype和auto的另一处重要区别是，decltype的结果类型与表达式形式密切相关。有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型：如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：
```
//decltype的表达式如果是加上了括号的变量，结果将是引用
decltype((i)) d;            //错误：d是int&，必须初始化
decltype(i) e;              //正确：e是一个（未初始化的）int
```

**decltype((variable))（注意是双层括号）的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用**。




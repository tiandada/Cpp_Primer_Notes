### 3.2 标准库类型string
标注库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。接下来的示例都假定亦包含了下述代码：
```
#include <string>
using std::string;
```
本节描述最常用的string操作，9.5节还将介绍另外一些。

#### 3.2.1 定义和初始化string对象
如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。表3.1列出了初始化string对象最常用的一些方式，下面是几个例子：
```
string s1;              //默认初始化，s1是一个空字符串
string s2 = s1;         //s2是s1的副本
string s3 = "hiya";     //s3是该字符串字面值的副本
string s4(10, 'c');     //s4的内容是cccccccccc
```
可以通过默认的方式初始化一个string对象，这样就会得到一个空的string，也就是说，该string对象中没有任何字符。如果提供了一个字符串字面值，则该字面值中除了最后那个空字符外其他所有的字符都被拷贝到新创建的string对象中去。如果提供的是一个数字和字符，则string对象的内容是给定字符连续重复若干次后得到的序列。

#### 表3.1：初始化string对象的方式
初始化|描述
:--|:--
string s1 | 默认初始化，s1是一个空串
string s2(s1) | s2是s1的副本
string s2 = s1|等价于s2(s1)，s2是s1的副本
string s3("value")|s3是字面值"value"的副本，除了字面值最后的那个空字符外
string s3 = "value"|等价于s3("value")，s3是字面值"value"的副本
string s4(n, 'c')|把s4初始化为由连续n个字符c组成的串

#### 直接初始化和拷贝初始化
由2.2.1节的学习可知，C++语言有几种不同的初始化方式，通过string我们可以清楚地开到在这些初始化方式之间到底什么区别和联系。如果使用等号（=）初始化一个变量，实际上执行的是**拷贝初始化**，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号。则执行的是**直接初始化**。

当初数值只有一个时，使用直接初始化或拷贝初始化都行。如果像上面的s4那样初始化要用到的值有多个，一般来说只能使用直接初始化的方式：
```
string s5 = "hiya";             //拷贝初始化
string s6("hiya");              //直接初始化
string s7(10, 'c');             //直接初始化、s7的内容是cccccccccc   
```
对于用多个值进行初始化的情况，非要用拷贝初始化的方式来处理也不是不可以，不过需要显示地创建一个（临时）对象用于拷贝：
```
string s8 = string(10, 'c');    //拷贝初始化，s8的内容是cccccccccc
```
s8的初始值是string(10, 'c')，它实际上是用数字10和字符c两个参数创建出来的一个string对象，然后这个string对象又拷贝给了s8。这条语句本质上等价于下面的两条语句：
```
string temp(10, 'c');       //temp的内容是cccccccccc
string s8 = temp;           //将temp拷贝给s8
```
其实我们可以看到，尽管初始化s8的语句合法，但和初始化s7的方式比较起来可读性较差，也没有任何补偿优势。

### 3.2.2 string对象上的操作
一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，就像Sales_item类的isbn函数那样，也能定义<<、+等各种运算符在该类对象上的新含义。表3.2中列举了string的大多数操作。

### 表3.2：string的操作
操作|含义
:--|:--
os<<s|将s写到输出流os当中，返回os
is>>s|从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, a)|从is中读取一行赋给s，返回is
s.empty()|s为空返回true，否则返回false
s.size()|返回s中字符的个数
s[n]|返回s中第n个字符的引用，位置n从0计起
s1+s2|返回s1和s2连接后的结果
s1=s2|用s2的副本代替s1中原来的字符
s1==s2|如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性
s1 != s2|判断对字母的大小写敏感
<，<=，>，>=|利用字符在字典中的顺序进行比较，且对字母的大小写敏感

### 读写string对象
第1章曾经介绍过，使用标准库中的iostream来读写int、double等内置类型的值。同样，也可以使用IO操作符读写string对象：
```
//注意：要想编译下面的代码还需要适当的#include语句和using声明
int main()
{
    string s;               //空字符串
    cin >> s;               //将string对象读入s，遇到空白停止
    cout << s << endl;      //输出s
    return 0;
}
```
这段程序首先定义了一个名为s的空string，然后将标准输入的内容读取到s中。在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，指导遇到下一处空白为止。

如上所述，如果程序的输入是"    Hello World!    "（注意开头和结尾的空格），则输出将是“Hello”，输出结果中没有任何空格。

和内置类型的输入输出操作一样，string对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连在一起：
```
string s1, s2;
cin >> s1 >> s2;                //把第一个输入读到s1中，第二个输入读到s2中
cout << s1 << s2 << endl;       //输出两个string对象
```
假如给上面这段程序输入与之前一样的内容“    Hello World!    ”，输出将是“HelloWorld!”。

### 读取未知数量的string对象
1.4.3节的程序可以读入数量未知的整数，下面编写一个类似的程序用于读取string对象：
```
int main()
{
    string word;
    while(cin >> cout)              //反复读取，直至到达文件末尾
        cout << word << endl;       //逐个输出单词，每个单词后面紧跟一个换行
    return 0;
}
```
在该程序中，读取的对象是string而非int，但是while语句的条件部分和之前版本的程序是一样的。该条件负责在读取时检测流的情况，如果流有效，也就是说没遇到文件结束或非法输入，那么执行while语句内部的操作。此时，循环体将输出刚刚从标准输入读取的内容。重复若干次之后，一旦遇到文件结束标记或非法输入循环也就结束了。

### 使用getline读取一整行
有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用**getline**函数代替原来的>>运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得到的结果是个空string。

和输入运算符一样，getline也会返回它的流参数。因此既然输入运算符能作为判断的条件，我们也能用getline的结果作为条件。例如，可以通过改写之前的程序让它一次输出一整行，而不再是每行输出一个词了：
```
int main()
{
    string line;
    //每次读入一整行，直至到达文件末尾
    while(getline(cin, line))
        cout << line << endl;
    return 0;
}
```
因为line中不包含换行符，所以我么你手动地加上换行操作符。和往常一样，使用endl结束当前行并刷新显示缓冲区。

触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中不包含该换行符。

### string的empty和size操作
顾名思义，empty函数根据string对象是否为空返回一个对应的布尔值（参见第2.1节）。和Sales_item类的isbn成员一样，empty也是string的一个成员函数。调用该函数的方法很简单，只要使用点操作符指明是哪个对象执行了empty函数就可以了。

通过每次改写之前的程序，可以做到只输出非空的行：
```
//每次读入一整行，遇到空行直接跳过
while (getlien(cin, line))
    if (!line.empty())
        cout << line << endl;
```
在上面的程序中，if语句的条件部分使用了**逻辑非运算符（!）**，它返回与其对象相反的结果。此例中，如果str不为空则返回真。

**size**函数返回string对象的长度（即string对象中字符的个数），可以使用size函数只输出长度超过80个字符的行：
```
string line;
//每次读入一整行，输出其中超过80个字符的行
while(getline(cin, line))
    if(line.size() > 80)
        cout << line << endl;
```

### string::size_type类型
对于size函数来说，返回一个int或者如前面2.1.1节所述的那样返回一个unsigned似乎都是合情合理的。但其实size函数返回的是一个string::size_type类型的值，下面就对这种新的类型稍作解释。

string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型**size_type**即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字size_type是在类型string中定义的。

尽管我们不太清楚string::size_type类型的细节，但有一点是肯定的：它是一个无符号类型的值而且能足够存放下任何string对象的大小。所有用存放string类的size函数返回值的变量，都应该是string::size_type类型的。

过去，string::size_type这种类型有点神秘，不太容易理解和使用。在C++11新标准中，允许编译器通过auto或者decltype来推断变量的类型：
```
auto len = len.size();          //len的类型是string::size_type
```
由于size函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假如n是一个具有负值的int，则表达式s.size() < n 的判断几乎肯定是true。这时因为负值n会自动地转换成一个比较大的无符号值。

如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。

### 比较string对象
string类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较string对象中的字符，并且对大小写敏感，也就是说，在比较时同一个字母的大写形式和小写形式时不同的。

相等性运算符（==和!=）分别检验两个string对象相等或不相等，string对象相等意味着它们的长度相同而且所包含的字符也全部相同。关系运算符<、<=、>、>=分别检验一个string对象是否小于、小于等于、大于、大于等于另外一个string对象。上述这些运算符都依照（大小写敏感）字典顺序：

1. 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。

2. 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

下面是string对象比较的一个示例：
```
string str = "Hello";
string phrase = "Hello World";
string slang = "Hiya";
```
根据规则1可判断，对象str小于对象phrase；根据规则2可判断，对象slang既大于str也大于phrase。

### 为string对象赋值
一般来说，在设计标准库类型时都力求在易用性上向内置类型看齐，因此大多数库类型都支持赋值操作。对于string类而言，允许把一个对象的值赋给另外一个对象：
```
string stl(10, 'c'), st2;       //st1的内容是cccccccccc；st2是一个空字符串
st1 = st2;                      //赋值：用st2的副本替换st1的内容
                                //此时st1和st2都是空字符串
```
### 两个string对象相加
两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。也就是说，对string对象使用加法运算符（+）的结果是一个新的string对象，它所包含的字符由两部分组成：前半部分是加法左侧string对象所含的字符、后半部分是加号右侧string对象所含的字符。另外，复合赋值运算符（+=）负责把右侧string对象的内容追加到左侧string对象的后面：
```
string s1 = "Hello, ", s2 = "world\n";
string s3 = s1 + s2;            //s3的内容是hello，world\n
s1 += s2;                       //等价于s1 = s1 + s2
```
### 字面值和string对象相加
如2.1.2节所讲的，即使一种类型并非所需，我们也可以使用它，不过前提是该种类型可以自动转换成所需的类型。因为标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。利用这一点将之前的程序改写为如下形式：
```
string s1 = "hello", s2 = "world";          //在s1和s2中都没有标点符号
string s3 = s1 + ", " + s2 + '\n';
``` 
当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string：
```
string s4 = s1 + ", ";              //正确：把一个string对象和一个字面值相加
string s5 = "hello" + ", ";         //错误：两个运算对象都不是string
//正确：每个加法运算符都有一个运算对象是string
string s6 = s1 + ", " + "world";
string s7 = "hello" + ", " + s2;    //错误：不能把字面值直接相加
```
s4和s5初始化时只用到了一个加法运算符，因此很容易判断是否合法。s6的初始化形式之前没有出现过，但其实它的工作机理和连续输入连续输出时一样的，可以用如下的形式分组：
```
string s6 = (s1 + ", ") + "world";
```
其中子表达式s1 + ","的结果是一个string对象，它同时作为第二个加法运算符的左侧运算对象，因此上述语句和下面的两个语句是等价的：
```
string tmp = s1 + ", ";             //正确：加法运算符有一个运算对象是string
s6 = tmp + "world";                 //正确：加法运算符有一个运算对象是string
```
另一个方面，s7的初始化是非法的，根据其语义加上括号后就成了下面的形式：
```
string s7 = ("hello" + ", ") + s2;      //错误：不能把字面值直接相加
```
很容易看到，括号内的子表达式试图把两个字符串字面值加到一起，而编译器根本没法做到这一点，所以这条语句是错误的。

因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串字面值与string是不同的类型。
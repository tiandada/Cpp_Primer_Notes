## 3.3 标准库类型vector
标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也常被称作**容器**。第II部分将对容器进行更为详细的介绍。

要想使用vector，必须包含适当的头文件。在后续的例子中，都将假定做了如下using声明：
```
#include <vector>
using std::vector;
```
C++语言既有**类模板**，也有函数模板，其中vector是一个类模板。只有对C++有了相当深入的理解才能写出模板，事实上，我们知道第16章才学会如何自定义模板。幸运的是，即使还不会创建模板，我们也可以先试着用用它。

模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括号，在括号内放上信息。

以vector为例，提供的额外信息时vector内所存放对象的类型：
```
vector<int> ivec;               //ivec保存int类型的对象
vector<Sales_item> Sales_vec;   //保存Sales_item类型的对象
vector<vector<string>> file;    //该向量的元素是vector对象
```
在上面的例子中，编译器根据模板vector生成了三种不同的类型：vector<int>、vector<Sales_item>和vector<vector<string>>。

vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>。

vector能容纳多大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。除此之外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector。

需要指出的是，在早期版本的C++标准中如果vector的元素还是vector（或者其他模板类型），则其定义的形式与现在的C++11新标准略有不同。过去，必须在外层vector对象的右尖括号和其元素类型之间添加一个空格，如应该写成vector<vector<int> >而非vector<vector<int>>。

某些编译器可能仍需以老式的声明语句来处理元素为vector的vector对象，如vector<vector<int> >。

### 3.3.1 定义和初始化vector对象
和任何一种类类型一样，vector模板控制着定义和初始化向量的方法。表3.4列出了定义vector对象的常用方法。

#### 表3.4：初始化vector对象的方法
初始化|含义
:--|:--
vector<T> v1|v1是一个空vector，它潜在的元素是T类型的，执行默认初始化
vector<T> v2(v1)|v2中包含有v1所有元素的副本
vector<T> v2 = v1|等价于v2(v1)，v2中包含有v1所有元素的副本
vector<T> v3(n, val)|v3包含了n个重复的元素，每个元素的值都是val
vector<T> v4(n)|v4包含了n个重复地执行了值初始化的对象
vector<T> v5{a,b,c...}|v5包含了初始值个数的元素，每个元素被赋予相应的初始值
vector<T> v5={a,b,c...}|等价于v5{a,b,c...}

可以默认初始化vector对象，从而创建一个指定类型的空vector：
```
vector<string> svec;	//默认初始化，svec不含任何元素
```
看起来空vector好像没什么用，但是很快我们就会知道程序在运行时可以很高效地往vector对象中添加元素。事实上，最常见的方式就是先定义一个空vector，然后当运行时获取到元素的值后在逐一添加。

当然也可以在定义vector对象时指定元素的初始值。例如，允许把一个vector对象的元素拷贝给另外一个vector对象。此时，新vector对象的元素就是原vectot对象对应元素的副本。注意两个vector对象的类型必须相同：
```
vector<int> ivec;			//初始状态为空
//在此处给ivec添加一些值
vector<int> ivec2(ivec);	//把ivec的元素拷贝给ivec2
vector<int> ivec3 = ivec;	//把ivec的元素拷贝给ivec3
vector<string> svec(ivec2);	//错误：svec的元素是string对象，不是int
```

### 列表初始化vector对象
C++11新标准还提供了另外一种为vector对象的元素赋初值的方法，及列表初始化。此时，用花括号括起来的0个或多个初始元素值被赋给vector对象：
```
vector<string> articles = {"a", "an", "the"};
```
上述vector对象包含三个对象：第一个是字符串"a"，第二个字符串"an"，最后一个是字符串"the"。

之前已经讲过，C++语言提供了几种不同的初始化方式。在大多数情况下这些初始化方式可以相互等价地使用，不过也并非一直如此。目前已经介绍的两种例外情况是：其一，使用拷贝初始化时（即使用=时），只能提供一个初始值；其二，如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号的形式初始化，而不能放在圆括号里：
```
vector<string> v1{"a","an","the"};	//列表初始化
vector<string> v2("a","an","the");	//错误
```
### 创建指定数量的元素
还可以用vector对象容纳的元素数量和所有元素的统一初始值来初始化vector对象：
```
vector<int> ivec(10, -1);		//10个int类型的元素，每个都被初始化为-1
vector<string> svec(10, "hi!");	//10个string类型的元素，
								//每个都被初始化为“hi!”
```
### 值初始化
通常情况下，可以只提供vector对象容纳的元素数量而不用略去初始值。此时库会创建一个**值初始化的**元素初值，并把它赋给容器中的所有元素。这个初始由vector对象中元素的类型决定。

如果vector对象的元素是内置类型，比如int，则元素初始值自动设为0。如果元素是某种类类型，比如string，则元素由类默认初始化：
```
vector<int> ivec(10);			//10个元素，每个都初始化为0
vector<string> svec(10);		//10个元素，每个都是空string对象
```
对这种初始化的方式有两个特殊限制：其一，有些类要求必须明确地提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。

其二，如果只提供了元素的数量而没有设定初始值，只能使用直接初始化：
```
vector<int> vi = 10;	//错误：必须使用直接初始化的形式指定向量大小
```
这里的10是用来说明如何初始化vector对象的，我们用它的本意是想创建含有10个值初始化了的元素的vector对象，而非把数字10"拷贝"到vector中。因此，此时不宜用拷贝初始化，7.5.4节将对这一点做更详细的介绍。

### 列表初始值还是元素数量？
在某种情况下，初始化的真是含义依赖于传递初始值时用的是花括号还是圆括号。例如，用一个整数类初始化vector<int>时，整数的含义可能是vector对象的容量也可能是元素的值。类似的，用两个整数来初始化vector<int>时，这个这两个整数可能一个是vector对象的容量，另一个是元素的初值，也可能它们是容量为2的vector对象中两个元素的初值。通过使用花括号或圆括号可以区分上述这些含义：
```
vector<int>l v1(10);	//v1有10个元素，每个的值都是0
vector<int> v2{10};		//v2有1个元素，该元素的值是10
vector<int> v3(10, 1);	//v3有10个元素，每个的值都是1
vector<int> v4{10, 1};	//v4有2个元素，值分别是10和1
```
如果用的是圆括号，可以说提供的值是用来构造vector对象的。例如，v1的初始值说明了vector对象的容量；v3的两个初始值则分别说明了vector对象的容量和元素的初值。

如果用的是花括号，可以表述成我们想列表初始化该vector对象。也就是说，初始化过程会尽可能地把花括号内的值当成是元素初始化的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式。在上例中，给v2和v4提供的初始值都能作为元素的值，所以它们都会执行列表初始化，vector对象v2包含一个元素而vector对象v4包含两个元素。

另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。例如，要想列表初始化一个含有string对象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要列表初始化vector对象的元素还是用给定的容量值来构造vector对象：
```
vector<string> v5{"hi"};		//列表初始化：v5有一个元素
vector<string> v6("hi");		//错误：不能使用字符床字面值构建vector对象
vector<string> v7{10};			//v7有10个默认初始化的元素
vector<string> v8{10, "hi"};	//v8有10个值为“hi”的元素
```
尽管在上面的例子中除了第二条语句之外都使用了花括号，但其实只有v5是列表初始化。要想列表初始化vector对象，所以v7和v8提供的值不能作为元素类型的初始值。确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。

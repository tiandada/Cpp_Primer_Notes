## 3.3 标准库类型vector
标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也常被称作**容器**。第II部分将对容器进行更为详细的介绍。

要想使用vector，必须包含适当的头文件。在后续的例子中，都将假定做了如下using声明：
```
#include <vector>
using std::vector;
```
C++语言既有**类模板**，也有函数模板，其中vector是一个类模板。只有对C++有了相当深入的理解才能写出模板，事实上，我们知道第16章才学会如何自定义模板。幸运的是，即使还不会创建模板，我们也可以先试着用用它。

模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括号，在括号内放上信息。

以vector为例，提供的额外信息时vector内所存放对象的类型：
```
vector<int> ivec;               //ivec保存int类型的对象
vector<Sales_item> Sales_vec;   //保存Sales_item类型的对象
vector<vector<string>> file;    //该向量的元素是vector对象
```
在上面的例子中，编译器根据模板vector生成了三种不同的类型：vector<int>、vector<Sales_item>和vector<vector<string>>。

vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>。

vector能容纳多大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。除此之外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector。

需要指出的是，在早期版本的C++标准中如果vector的元素还是vector（或者其他模板类型），则其定义的形式与现在的C++11新标准略有不同。过去，必须在外层vector对象的右尖括号和其元素类型之间添加一个空格，如应该写成vector<vector<int> >而非vector<vector<int>>。

某些编译器可能仍需以老式的声明语句来处理元素为vector的vector对象，如vector<vector<int> >。


## 3.1 命名空间的using声明
目前为止，我们用到的库函数基本上都属于命名空间std，而程序也显示地将这一点标示了出来。例如，std::cin表示从标准输入中读取内容。此外使用作用域操作符（::）的含义时：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。因此，std::cin的意思就是要使用命名空间std中的名字cin。

上面的方法显得比较繁琐，然而幸运的是，通过简单的途径也能使用到命名空间中的成员。本节将学习其中一种最安全的方法，也就是使用**using声明**，18.2.2会介绍另一种方法。

有了using声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。using声明具有如下的形式：
```
using namespace::name;
```
一旦声明了上述语句，就可以直接访问命名空间中的名字：
```
#include <iostream>
//using声明，当我们使用名字cin时，从命名空间std中获取它
using std::cin;

int main()
{
    int i;
    cin >> i;           //正确：cin和std::cin含义相同
    cout << i;          //错误：没有对应的using声明，必须使用完整的名字
    std::cout << i;     //正确：显示地从std中使用cout
    return 0;
}
```
### 每个名字都需要独立的using声明
按照规定，每个using声明引入命名空间中的一个成员。例如，可以把要用到的标准库中的名字都以using生命的形式表示出来，重写1.2节的程序如下：
```
#include <iostream>
//通过下列using声明，我们可以使用标准库中的名字
using std::cin;
using std::cout; using std::endl;
int main()
{
    cout << "Enter two numbers:" << endl;
    int v1, v2;
    cin >> v1 >> v2;
    cout << "The sum of " << v1 << " and " << v2
         << " is " << v1 + v2 << endl;
    return 0;
}
```
在上述程序中，一开始就有对cin、cout和endl的using声明，着意味着我们不用再添加std::形式的前缀就能直接使用它们。C++语言的形式比较自由，因此既可以一行只放一条using语句，也可以一行放上对条。不过要注意，用到的每个名字都必须有自己的声明语句，而且每句话都得以分号结束。

### 头文件不应包含using声明
位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

### 一点注意事项
经本节所述，后面的所有例子将假设，但凡用到的标准库中的名字都已经使用using语句声明过了。例如，我们将在代码中直接使用cin，而不再使用std::cin。

为了让书中的代码尽量简洁，今后将不再把所有using声明和#include指令一一标出。

### 3.2 标准库类型string
标注库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。接下来的示例都假定亦包含了下述代码：
```
#include <string>
using std::string;
```
本节描述最常用的string操作，9.5节还将介绍另外一些。

#### 3.2.1 定义和初始化string对象
如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。表3.1列出了初始化string对象最常用的一些方式，下面是几个例子：
```
string s1;              //默认初始化，s1是一个空字符串
string s2 = s1;         //s2是s1的副本
string s3 = "hiya";     //s3是该字符串字面值的副本
string s4(10, 'c');     //s4的内容是cccccccccc
```
可以通过默认的方式初始化一个string对象，这样就会得到一个空的string，也就是说，该string对象中没有任何字符。如果提供了一个字符串字面值，则该字面值中除了最后那个空字符外其他所有的字符都被拷贝到新创建的string对象中去。如果提供的是一个数字和字符，则string对象的内容是给定字符连续重复若干次后得到的序列。

#### 表3.1：初始化string对象的方式
初始化|描述
:--|:--
string s1 | 默认初始化，s1是一个空串
string s2(s1) | s2是s1的副本
string s2 = s1|等价于s2(s1)，s2是s1的副本
string s3("value")|s3是字面值"value"的副本，除了字面值最后的那个空字符外
string s3 = "value"|等价于s3("value")，s3是字面值"value"的副本
string s4(n, 'c')|把s4初始化为由连续n个字符c组成的串

#### 直接初始化和拷贝初始化
由2.2.1节的学习可知，C++语言有几种不同的初始化方式，通过string我们可以清楚地开到在这些初始化方式之间到底什么区别和联系。如果使用等号（=）初始化一个变量，实际上执行的是**拷贝初始化**，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号。则执行的是**直接初始化**。

当初数值只有一个时，使用直接初始化或拷贝初始化都行。如果像上面的s4那样初始化要用到的值有多个，一般来说只能使用直接初始化的方式：
```
string s5 = "hiya";             //拷贝初始化
string s6("hiya");              //直接初始化
string s7(10, 'c');             //直接初始化、s7的内容是cccccccccc   
```
对于用多个值进行初始化的情况，非要用拷贝初始化的方式来处理也不是不可以，不过需要显示地创建一个（临时）对象用于拷贝：
```
string s8 = string(10, 'c');    //拷贝初始化，s8的内容是cccccccccc
```
s8的初始值是string(10, 'c')，它实际上是用数字10和字符c两个参数创建出来的一个string对象，然后这个string对象又拷贝给了s8。这条语句本质上等价于下面的两条语句：
```
string temp(10, 'c');       //temp的内容是cccccccccc
string s8 = temp;           //将temp拷贝给s8
```
其实我们可以看到，尽管初始化s8的语句合法，但和初始化s7的方式比较起来可读性较差，也没有任何补偿优势。

### 3.2.2 string对象上的操作
一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，就像Sales_item类的isbn函数那样，也能定义<<、+等各种运算符在该类对象上的新含义。表3.2中列举了string的大多数操作。

### 表3.2：string的操作
操作|含义
:--|:--
os<<s|将s写到输出流os当中，返回os
is>>s|从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, a)|从is中读取一行赋给s，返回is
s.empty()|s为空返回true，否则返回false
s.size()|返回s中字符的个数
s[n]|返回s中第n个字符的引用，位置n从0计起
s1+s2|返回s1和s2连接后的结果
s1=s2|用s2的副本代替s1中原来的字符
s1==s2|如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性
s1 != s2|判断对字母的大小写敏感
<，<=，>，>=|利用字符在字典中的顺序进行比较，且对字母的大小写敏感

### 读写string对象
第1章曾经介绍过，使用标准库中的iostream来读写int、double等内置类型的值。同样，也可以使用IO操作符读写string对象：
```
//注意：要想编译下面的代码还需要适当的#include语句和using声明
int main()
{
    string s;               //空字符串
    cin >> s;               //将string对象读入s，遇到空白停止
    cout << s << endl;      //输出s
    return 0;
}
```
这段程序首先定义了一个名为s的空string，然后将标准输入的内容读取到s中。在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，指导遇到下一处空白为止。

如上所述，如果程序的输入是"    Hello World!    "（注意开头和结尾的空格），则输出将是“Hello”，输出结果中没有任何空格。

和内置类型的输入输出操作一样，string对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连在一起：
```
string s1, s2;
cin >> s1 >> s2;                //把第一个输入读到s1中，第二个输入读到s2中
cout << s1 << s2 << endl;       //输出两个string对象
```
假如给上面这段程序输入与之前一样的内容“    Hello World!    ”，输出将是“HelloWorld!”。

### 读取未知数量的string对象
1.4.3节的程序可以读入数量未知的整数，下面编写一个类似的程序用于读取string对象：
```
int main()
{
    string word;
    while(cin >> cout)              //反复读取，直至到达文件末尾
        cout << word << endl;       //逐个输出单词，每个单词后面紧跟一个换行
    return 0;
}
```
在该程序中，读取的对象是string而非int，但是while语句的条件部分和之前版本的程序是一样的。该条件负责在读取时检测流的情况，如果流有效，也就是说没遇到文件结束或非法输入，那么执行while语句内部的操作。此时，循环体将输出刚刚从标准输入读取的内容。重复若干次之后，一旦遇到文件结束标记或非法输入循环也就结束了。

### 使用getline读取一整行
有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用**getline**函数代替原来的>>运算符。getline函数的参数时一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被都进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得到的结果是个空string。
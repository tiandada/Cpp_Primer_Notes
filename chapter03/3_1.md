## 3.1 命名空间的using声明
目前为止，我们用到的库函数基本上都属于命名空间std，而程序也显示地将这一点标示了出来。例如，std::cin表示从标准输入中读取内容。此外使用作用域操作符（::）的含义时：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。因此，std::cin的意思就是要使用命名空间std中的名字cin。

上面的方法显得比较繁琐，然而幸运的是，通过简单的途径也能使用到命名空间中的成员。本节将学习其中一种最安全的方法，也就是使用**using声明**，18.2.2会介绍另一种方法。

有了using声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。using声明具有如下的形式：
```
using namespace::name;
```
一旦声明了上述语句，就可以直接访问命名空间中的名字：
```
#include <iostream>
//using声明，当我们使用名字cin时，从命名空间std中获取它
using std::cin;

int main()
{
    int i;
    cin >> i;           //正确：cin和std::cin含义相同
    cout << i;          //错误：没有对应的using声明，必须使用完整的名字
    std::cout << i;     //正确：显示地从std中使用cout
    return 0;
}
```
### 每个名字都需要独立的using声明
按照规定，每个using声明引入命名空间中的一个成员。例如，可以把要用到的标准库中的名字都以using生命的形式表示出来，重写1.2节的程序如下：
```
#include <iostream>
//通过下列using声明，我们可以使用标准库中的名字
using std::cin;
using std::cout; using std::endl;
int main()
{
    cout << "Enter two numbers:" << endl;
    int v1, v2;
    cin >> v1 >> v2;
    cout << "The sum of " << v1 << " and " << v2
         << " is " << v1 + v2 << endl;
    return 0;
}
```
在上述程序中，一开始就有对cin、cout和endl的using声明，着意味着我们不用再添加std::形式的前缀就能直接使用它们。C++语言的形式比较自由，因此既可以一行只放一条using语句，也可以一行放上对条。不过要注意，用到的每个名字都必须有自己的声明语句，而且每句话都得以分号结束。

### 头文件不应包含using声明
位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

### 一点注意事项
经本节所述，后面的所有例子将假设，但凡用到的标准库中的名字都已经使用using语句声明过了。例如，我们将在代码中直接使用cin，而不再使用std::cin。

为了让书中的代码尽量简洁，今后将不再把所有using声明和#include指令一一标出。

### 3.2 标准库类型string
标注库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。接下来的示例都假定亦包含了下述代码：
```
#include <string>
using std::string;
```
本节描述最常用的string操作，9.5节还将介绍另外一些。

#### 3.2.1 定义和初始化string对象
如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。表3.1列出了初始化string对象最常用的一些方式，下面是几个例子：
```
string s1;              //默认初始化，s1是一个空字符串
string s2 = s1;         //s2是s1的副本
string s3 = "hiya";     //s3是该字符串字面值的副本
string s4(10, 'c');     //s4的内容是cccccccccc
```
可以通过默认的方式初始化一个string对象，这样就会得到一个空的string，也就是说，该string对象中没有任何字符。如果提供了一个字符串字面值，则该字面值中除了最后那个空字符外其他所有的字符都被拷贝到新创建的string对象中去。如果提供的是一个数字和字符，则string对象的内容是给定字符连续重复若干次后得到的序列。

#### 表3.1：初始化string对象的方式
初始化|描述
:--|:--
string s1 | 默认初始化，s1是一个空串
string s2(s1) | s2是s1的副本
string s2 = s1|等价于s2(s1)，s2是s1的副本
string s3("value")|s3是字面值"value"的副本，除了字面值最后的那个空字符外
string s3 = "value"|等价于s3("value")，s3是字面值"value"的副本
string s4(n, 'c')|把s4初始化为由连续n个字符c组成的串

#### 直接初始化和拷贝初始化
由2.2.1节的学习可知，C++语言有几种不同的初始化方式，通过string我们可以清楚地开到在这些初始化方式之间到底什么区别和联系。如果使用等号（=）初始化一个变量，实际上执行的是**拷贝初始化**，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号。则执行的是**直接初始化**。

当初数值只有一个时，使用直接初始化或拷贝初始化都行。如果像上面的s4那样初始化要用到的值有多个，一般来说只能使用直接初始化的方式：
```
string s5 = "hiya";             //拷贝初始化
string s6("hiya");              //直接初始化
string s7(10, 'c');             //直接初始化、s7的内容是cccccccccc   
```
对于用多个值进行初始化的情况，非要用拷贝初始化的方式来处理也不是不可以，不过需要显示地创建一个（临时）对象用于拷贝：
```
string s8 = string(10, 'c');    //拷贝初始化，s8的内容是cccccccccc
```
s8的初始值是string(10, 'c')，它实际上是用数字10和字符c两个参数创建出来的一个string对象，然后这个string对象又拷贝给了s8。这条语句本质上等价于下面的两条语句：
```
string temp(10, 'c');       //temp的内容是cccccccccc
string s8 = temp;           //将temp拷贝给s8
```
其实我们可以看到，尽管初始化s8的语句合法，但和初始化s7的方式比较起来可读性较差，也没有任何补偿优势。

### 3.2.2 string对象上的操作
一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，就像Sales_item类的isbn函数那样，也能定义<<、+等各种运算符在该类对象上的新含义。表3.2中列举了string的大多数操作。

### 表3.2：string的操作
操作|含义
:--|:--
os<<s|将s写到输出流os当中，返回os
is>>s|从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, a)|从is中读取一行赋给s，返回is
s.empty()|s为空返回true，否则返回false
s.size()|返回s中字符的个数
s[n]|返回s中第n个字符的引用，位置n从0计起
s1+s2|返回s1和s2连接后的结果
s1=s2|用s2的副本代替s1中原来的字符
s1==s2|如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性
s1 != s2|判断对字母的大小写敏感
<，<=，>，>=|利用字符在字典中的顺序进行比较，且对字母的大小写敏感

### 读写string对象
第1章曾经介绍过，使用标准库中的iostream来读写int、double等内置类型的值。同样，也可以使用IO操作符读写string对象：
```
//注意：要想编译下面的代码还需要适当的#include语句和using声明
int main()
{
    string s;               //空字符串
    cin >> s;               //将string对象读入s，遇到空白停止
    cout << s << endl;      //输出s
    return 0;
}
```
这段程序首先定义了一个名为s的空string，然后将标准输入的内容读取到s中。在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，指导遇到下一处空白为止。

如上所述，如果程序的输入是"    Hello World!    "（注意开头和结尾的空格），则输出将是“Hello”，输出结果中没有任何空格。

和内置类型的输入输出操作一样，string对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连在一起：
```
string s1, s2;
cin >> s1 >> s2;                //把第一个输入读到s1中，第二个输入读到s2中
cout << s1 << s2 << endl;       //输出两个string对象
```
假如给上面这段程序输入与之前一样的内容“    Hello World!    ”，输出将是“HelloWorld!”。

### 读取未知数量的string对象
1.4.3节的程序可以读入数量未知的整数，下面编写一个类似的程序用于读取string对象：
```
int main()
{
    string word;
    while(cin >> cout)              //反复读取，直至到达文件末尾
        cout << word << endl;       //逐个输出单词，每个单词后面紧跟一个换行
    return 0;
}
```
在该程序中，读取的对象是string而非int，但是while语句的条件部分和之前版本的程序是一样的。该条件负责在读取时检测流的情况，如果流有效，也就是说没遇到文件结束或非法输入，那么执行while语句内部的操作。此时，循环体将输出刚刚从标准输入读取的内容。重复若干次之后，一旦遇到文件结束标记或非法输入循环也就结束了。

### 使用getline读取一整行
有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用**getline**函数代替原来的>>运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得到的结果是个空string。

和输入运算符一样，getline也会返回它的流参数。因此既然输入运算符能作为判断的条件，我们也能用getline的结果作为条件。例如，可以通过改写之前的程序让它一次输出一整行，而不再是每行输出一个词了：
```
int main()
{
    string line;
    //每次读入一整行，直至到达文件末尾
    while(getline(cin, line))
        cout << line << endl;
    return 0;
}
```
因为line中不包含换行符，所以我么你手动地加上换行操作符。和往常一样，使用endl结束当前行并刷新显示缓冲区。

触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中不包含该换行符。

### string的empty和size操作
顾名思义，empty函数根据string对象是否为空返回一个对应的布尔值（参见第2.1节）。和Sales_item类的isbn成员一样，empty也是string的一个成员函数。调用该函数的方法很简单，只要使用点操作符指明是哪个对象执行了empty函数就可以了。

通过每次改写之前的程序，可以做到只输出非空的行：
```
//每次读入一整行，遇到空行直接跳过
while (getlien(cin, line))
    if (!line.empty())
        cout << line << endl;
```
在上面的程序中，if语句的条件部分使用了**逻辑非运算符（!）**，它返回与其对象相反的结果。此例中，如果str不为空则返回真。

**size**函数返回string对象的长度（即string对象中字符的个数），可以使用size函数只输出长度超过80个字符的行：
```
string line;
//每次读入一整行，输出其中超过80个字符的行
while(getline(cin, line))
    if(line.size() > 80)
        cout << line << endl;
```

### string::size_type类型
对于size函数来说，返回一个int或者如前面2.1.1节所述的那样返回一个unsigned似乎都是合情合理的。但其实size函数返回的是一个string::size_type类型的值，下面就对这种新的类型稍作解释。

string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型**size_type**即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字size_type是在类型string中定义的。

尽管我们不太清楚string::size_type类型的细节，但有一点是肯定的：它是一个无符号类型的值而且能足够存放下任何string对象的大小。所有用存放string类的size函数返回值的变量，都应该是string::size_type类型的。

过去，string::size_type这种类型有点神秘，不太容易理解和使用。在C++11新标准中，允许编译器通过auto或者decltype来推断变量的类型：
```
auto len = len.size();          //len的类型是string::size_type
```
由于size函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假如n是一个具有负值的int，则表达式s.size() < n 的判断几乎肯定是true。这时因为负值n会自动地转换成一个比较大的无符号值。

如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。

### 比较string对象
string类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较string对象中的字符，并且对大小写敏感，也就是说，在比较时同一个字母的大写形式和小写形式时不同的。

相等性运算符（==和!=）分别检验两个string对象相等或不相等，string对象相等意味着它们的长度相同而且所包含的字符也全部相同。关系运算符<、<=、>、>=分别检验一个string对象是否小于、小于等于、大于、大于等于另外一个string对象。上述这些运算符都依照（大小写敏感）字典顺序：

1. 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。

2. 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

下面是string对象比较的一个示例：
```
string str = "Hello";
string phrase = "Hello World";
string slang = "Hiya";
```
根据规则1可判断，对象str小于对象phrase；根据规则2可判断，对象slang既大于str也大于phrase。






## 6.2 参数传递
形参初始化的机理与变量初始化一样。

和其他变量一样，形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。

当形参是引用类型时，我们说它对应的实参被**引用传递**或者函数被**传引用调用**。和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。

当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被**值传递**或者函数被**传值调用**。

### 6.2.1 传值参数
当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值：
```
int n = 0;          //int类型的初始变量
int i = n;          //i是n的值的副本
i = 42;             //i的值改变；n的值不变
```
传值参数的机理完全一样，函数对形参做的所有操作都不会影响实参。例如，在fact函数内对变量val执行递减操作：
```
ret *= val--;       //将val的值减1
```
尽管fact函数改变了val的值，但是这个改动不会影响传入fact的实参。调用fact(i)不会改变i的值。

### 指针形参
指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指地对象，所以通过指针可以修改它所指对象的值：
```
int n = 0, i = 42;
int *p = &n, *q = &i;   //p指向n；q指向i
*p = 42;                //n的值改变；p不变
p = q;                  //p现在指向了i；但是i和n的值都不变
```
指针形参的行为与之类似：
```
// 该函数接受一个指针，然后将指针所指的值置为0
void reset(int *ip)
{
    *ip = 0;        //只改变指针ip所指对象的值
    ip = 0;         //只改变了ip的局部拷贝，实参未被改变
}
```
调用reset函数之后，实参所指的对象被置为0，但是实参本身并没有改变：
```
int i = 42;
reset(&i);                      //改变i的值而非i的地址
cout << "i = " << i << endl;    //输出i = 0
```
熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参替代指针。

### 6.2.2 传引用参数
通过使用引用形参，允许函数改变一个或多个实参的值。

举个例子，我们可以改写上一小节的reset程序，使其接受的参数类型而非指针：
```
//该函数接受一个int对象的引用，然后将对象的值置为0
void reset(int &i)      //i是传给reset函数的对象的另一个名字
{
    i = 0;              //改变了i所因对象的值
}
```
和其他引用一样，引用形参绑定初始化它的对象。当调用这一版本的reset函数时，i绑定我们传给函数的int对象，此时改变i也就是i所引对象的值。此例中，被改变的对象是传入reset的实参。

调用这一版本的reset函数时，我们直接传入对象而无须传递对象的地址：
```
int j = 42;
reset(j);                       //j采用传引用方式，它的值被改变
cout << "j = " << j << endl;    //输出j = 0
```
在上述调用过程中，形参i仅仅是j的又一个名字。在reset内部对i的使用即是对j的使用。

### 使用引用避免拷贝
拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。

举个例子，我们准备编写一个函数比较两个string对象的长度。因为string对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明指的选择。又因为比较长度无须改变string对象的内容，所以把形参定义成对常量的引用：
```
//比较两个string对象的长度
bool isShorter(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}
```
当函数无须修改引用形参的值时最好使用常量引用。

如果函数无须改变引用形参的值，最好将其声明为常量引用。

### 使用引用形参返回额外信息
一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用参数为我们一次返回多个结果提供了有效的途径。举个例子，我们定义了一个名为find_char的函数，它返回在string对象中某个指定字符第一次出现的位置。同时，我们也希望函数能返回该字符出现的总次数。

该如何定义函数使得它能够既返回位置也返回次数呢？一种方法是定义一个新的数据类型，让它包含位置和数量两个成员。还有另一种更简单的方法，我们可以给函数传入一个额外的引用实参，令其保存字符出现的次数：
```
// 返回s中c第一次出现的位置索引
// 引用形参occurs负责统计c出现的总次数
string::size_type find_char(const string &s, char c,
                            string::size_type &occurs)
{
    auto ret = s.size();            //第一次出现的位置（如果有的话）
    occurs = 0;                     //设置表示出现次数的形参的值
    for (decltype(ret) i = 0; i != s.size(); ++i)
    {
        if (s[i] == c)
        {
            if (ret == s.size())
                ret = i;            //记录c第一次出现的位置
            ++occurs;
        }
    }
    return ret;                     //出现次数通过occurs隐式地返回
}
```
当我们调用find_char函数时，必须传入三个参数：作为查找范围的一个string对象、要找的字符以及一个用于保存字符出现次数的size_type对象。假设s是一个string对象，ctr是一个size_type对象，则我们通过如下形式调用find_char函数：
```
auto index = find_char(s, 'o', ctr);
```
调用完成后，如果string对象中确实存在o，那么ctr的值就是o出现的次数，index指向o第一次出现的位置：否则如果string对象中没有o，index等于s.size()而ctr等于0。


### 6.2.3 const形参和实参
当形参是const时，必须注意2.4.3节关于顶层const的讨论。如前所述，顶层const作用于对象本身：
```
const int ci = 42;      //不能改变ci，const是顶层的
int i = ci;             //正确：当拷贝ci时，忽略了它的顶层const
int * const p = &i;     //const是底层的，不能给p赋值
*p = 0;                 //正确：通过p改变对象的内容是允许的，现在i变成了0
```
和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的：
```
void fcn(const in i) { /* fcn能够读取i，但是不能向i写值 */ }
```
调用fcn函数时，既可以传入const int也可以传入int。忽略掉形参的顶层const可能产生意想不到的结果：
```
void fcn(const int i) { /*fcn能够读取i，但是不能向i写值*/ }
void fcn(int i) { /* ... */ } //错误：重复定义了fcn(int)
```
在C++语言中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别。因为顶层const别忽略掉了，所以在上面的代码中传入两个fcn函数的参数可以完全一样。因此第二个fcn是错误的，尽管形式上有差异，但实际上它的形参和第一个fcn的形参没什么不同。

### 指针或引用形参于const
形参的初始化方式和变量的初始化方式是一样的，所以回顾通用的初始化规则有助于理解本节知识。我们可以使用非常量初始化一个底层const对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。
```
int i = 42;
const int *cp = &i;     //正确：但是cp不能改变i
const int &r = i;       //正确：但是r不能改变i
const int &r2 = 42;     //正确
int *p = cp;            //错误：p的类型和cp的类型不匹配
int &r3 = r;            //错误：r3的类型和r的类型不匹配
int &r4 = 42;           //错误：不能用字面值初始化一个非常量引用
```
将同样的初始化规则应用到参数传递上可得如下形式：
```
int i = 0;
const int ci = i;
string::size_type ctr = 0;
reset(&i);              //调用形参类型是int*的reset函数
reset(&ci);             //错误：不能用指向const int对象的指针初始化int*
reset(i);               //调用形参类型是int&的reset函数
reset(ci);              //错误：不能把普通引用绑定到const对象ci上
reset(42);              //错误：不能把普通引用绑定到字面值上
reset(ctr);             //错误：类型不匹配，ctr是无符号类型
// 正确：find_char的第一个形参是对常量的引用
fing_char("Hello World!", 'o', ctr);
```
要想调用引用版本的reset，只能使用int类型的对象，而不能使用字面值、求值结果为int的表达式、需要转化的对象或者const int类型的对象。类似的，要想调用指针版本的reset只能使用int*。另一方面，我们能传递一个字符串字面值作为find_char的第一个实参，这时因为该函数的引用形参是常量引用，而C++允许我们用字面值初始化常量引用。

### 尽量使用常量引用
把函数不会改变的形参定义成（普通的）引用时一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此时，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。就像刚刚看到的，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

这种错误绝不像看起来那么简单，它可能造成出人意料的后果。以6.2.2节的find_char函数为例，那个函数（正确地）将它的string类型的形参定义成常量引用。假如我们把它定义成普通的string&：
```
//不良设计：第一个形参的类型应该是const string&
string::size_type find_char(string &s, char c,
                            string::size_type &occurs);
```
则只能将find_char函数作用于string对象。类似下面这样的调用
```
find_char("Hello World", 'o', ctr);
```
将在编译时发生错误。

还有一个更难察觉的问题，假如其他函数（正确地）将它们的形参定义成常量引用，那么第二个版本的find_char无法在此类函数中正常使用。举个例子，我们希望在一个判断string对象是否是句子的函数中使用find_char:
```
bool is_sentence(const string &s)
{
    // 如果在s的末尾有且只有一个句号，则s是一个句子
    string::size_type ctr = 0;
    return find_char(s, '.', ctr) == s.size() - 1 && ctr == 1;
}
```
如果find_char的第一个形参类型是string&，那么上面这条调用find_char的语句将在编译时发生错误。原因在于s是常量引用，但find_char被（不正确的）定义成只能接受普通引用。

解决该问题的一种思路是修改is_sentence的形参类型，但是这么做只不过转移了错误而已，结果是is_sentence函数的调用者只能接受非常量string对象了。

正确的修改思路是改正find_char函数的形参。如果实在不能修改find_char，就在is_sentence内部定义一个string类型的对象，令其为s的副本，然后把这个string对象传递给find_char。



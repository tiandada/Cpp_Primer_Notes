## 6.5 特殊用途语言特性
默认实参、内联函数和constexpr函数
### 6.5.1 默认实参
某些函数有这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的**默认实参**。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。

例如，我们使用string对象表示窗口的内容。一般情况下，我们希望该窗口的高、宽和背景字符都使用默认值。但是同时我们也应该允许用户为这几个参数自由指定与默认值不同的数组。为了使得窗口函数既能接纳默认值，也能接受用户指定的值，我们把它定义成如下的形式：
```
typedef string::size_type sz;
string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
```
需要注意的时，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

#### 使用默认实参调用函数
如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。例如，screen函数为它的所有形参提供了默认实参，所以我们可以使用0、1、2或3个实参调用该函数：
```
string window;
window = screen();                  //等价于screen(24,80,' ');
window = screen(66);                //等价于screen(66,80,' ');
window = screen(66, 256);           //screen(66,256,' ');
window = screen(66,256,'#');        //screen(66,256,'#');
```
函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参(靠右侧位置)。例如，要想覆盖backgrnd的默认值，必须为ht和wid提供实参：
```
window = screen(, , '?');           //错误：只能省略尾部的实参
window = screen('?');               //调用screen('?',80,' ');
```
需要注意，第二个调用传递一个字符值，是合法的调用，然而尽管如此，它的实际效果却与书写的意图不符。char可以转换成string::size_type类型。

当设计含有默认实参的函数时，其中一项任务时合理设置形参的顺序，尽量让不怎么使用默认值得形参出现在前面，而让那些经常使用默认值得形参出现在后面。

#### 默认实参声明
对于函数的声明来说，通常的习惯是将其放到头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能赋予一次默认值。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。假如给定：
```
// 表示高度和宽度的形参没有默认值
string screen(sz, sz, char = ' ');
```
我们不能修改一个已经存在的默认值：
```
string screen(sz, sz, char = '*');              //错误：重复声明
```
但是可以按照如下形式添加默认实参
```
string screen(sz = 24, sz = 80, char);          //正确：添加默认实参
```
通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。

#### 默认实参初始值
局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：
```
// wd、def和ht的声明必须出现在函数之外
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);
string window = screen();       //调用screen(ht(), 80, ' ');
```
用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：
```
void f2()
{
    def = '*';          //改变默认实参的值
    sz wd = 100;        //隐藏了外层定义的wd，但是没有改变默认值
    window = screen();  //调用screen(ht(), 80, '*')
}
```
我们在函数f2内部改变了def的值，所以对screen的调用将会传递这个更新过的值。另一方面，虽然我们的函数还声明了一个局部变量用于隐藏外层的wd，但是该局部变量与传递给screen的默认实参没有任何关系。

### 6.5.2 内联函数和constexpr函数
#### 内联函数可避免函数调用的开销
将函数指定为**内联函数**，通常就是将它在每个调用点上“内联地”展开。假设我们把shorterString函数定义成内联函数，则如下调用
```
cout << shorterString(s1, s2) << endl;
```
将在编译过程中展开成类似于下面的形式
```
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
```
从而消除了shorterString函数的运行开销。

在shorterString函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了：
```
// 内联版本：寻找两个string对象中较短的那个
inline const string &
shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```
内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。

一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个75含的函数也不大可能在调用点内联地展开。

### constexpr函数
**constexpr函数**是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：
```
constexpr int new_sz() { return 42 };
constexpr int foo = new_sz();   //正确：foo是一个常量表达式
```
我们把new_sz定义成无参数的constexpr函数。因为编译器能在程序编译时验证new_sz函数返回的常量表达式，所以可以用new_sz函数初始化constexpr类型的变量foo。

执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。

constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名以及using声明。

我们允许constexpr函数的返回值并非一个变量：
```
// 如果arg是常量表达式，则scale(arg)也是常量表达式
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }
```
当scale的实参是常量表达式时，它的返回值也是常量表达式；反之则不然：
```
int arr[scale(2)];          //正确：scale(2)是常量表达式
int i = 2;                  //i不是常量表达式
int a2[scale(i)];           //错误：scale(i)不是常量表达式
```


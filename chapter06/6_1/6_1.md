## 6.1 函数基础
### 编写函数
举个例子，我们准备编写一个求数阶乘的程序。n的阶乘是从1到n所有数字的乘积，例如5的乘积是120。
```
1 * 2 * 3 * 4 * 5 = 120
```
程序如下所示：
```
int fact(int val)
{
	int ret = 1;		//局部变量，用于保存计算结果
	while(val > 1)
		ret *= val--;	//把ret和val的乘积赋给ret，然后将val减1
	return ret;			//返回结果
}
```
函数的名字是fact，它作用于一个整型变量，放回一个整型值。在while循环内部，在每次迭代时用后置递减运算符将val的值减1。return语句负责结束fact并返回ret的值。

### 调用函数
要调用fact函数，必须提供一个整数值，调用得到的结果也是一个整数：
```
int main()
{
	int j = fact(5);	//j等于120，即fact(5)的结果
	cout << "5! is " << j << endl;
	return 0;
}
```
函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，**主调函数**的执行被暂时中断，被调函数开始执行。

当遇到一条return语句时函数技术执行过程。和函数调用一样，return语句也完成两项工作：一是返回return语句中的值，二是将控制权从被调函数转移回主调函数。函数的返回值用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分。

### 函数返回类型
大多数类型都能用作函数返回类型。一种特殊的返回类型是void，它表示函数不返回任何值。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。我们将在6.3.3节介绍如何定义一种特殊的函数，它的返回值是数组的指针（或引用），在6.7节将介绍如何返回指向函数的指针。

### 6.1.1 局部变量
在C++语言中，名字有作用域，对象有**生命周期**。理解这两个概念非常重要。
- 名字的作用域是程序文本的一部分，名字在其中可见。
- 对象的生命周期是程序执行过程中该对象存在的一段时间。

如我们所知，函数体是一个语句块。块构成一个新的作用域，我们可以在其中定义变量。形参和函数体内部定义的变量统称为**局部变量**。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会**隐藏**在外层作用域中同名的其他所有声明中。

在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。

###　自动对象
对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为**自动对象**。当块的执行结束后，块中创建的自动对象的值就会变成未定义的了。

形参是一种自动对象。函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数种植，形参也就被销毁。

我们用传递给函数的实参初始化形参对应的自动对象。对于局部变量对应的自动对象来说，则分为两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化。这意味着内置类型的未初始化局部变量将产生未定义的值。

### 局部静态对象
某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。**局部静态对象**在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。

举个例子，下面的函数统计它自己被调用了多少次，这样的函数也许没什么实际意义，但是足够说明问题：
```
size_t count_calls()
{
	static size_t ctr = 0;	//调用结束后，这个值仍然有效
	return ++ctr;
}
int main()
{
	for (size_t i = 0; i != 10; ++i)
		cout << count_calls() << endl;
	return 0;
}
```
这段程序将输出从１到10的数字。

在控制流第一次经过ctr的定义之前，ctr被创建并初始化为0。每次调用将ctr加1并返回新值。每次执行count_calls函数时，变量ctr的值都已经存在并且等于函数上一次退出时ctr的值。因此，第二次调用时ctr的值是1，第三次调用时ctr的值是2，以此类推。

如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。

### 6.1.2 函数声明
和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。唯一的例外是如15.3节将要介绍的，如果一个函数永远也不会被我们用到，那么它可以只有声明没有定义。

函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。

因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。尽管如此，写上形参的名字还是有用处的，它可以帮助使用者更好地理解函数的功能：
```
// 我们选择beg和end作为形参的名字以表示这两个迭代期划定了输出值的范围
void print(vector<int>::const_iterator beg, vector<int>::const_iterator end);
```
函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作**函数原型**。

### 在头文件中进行函数声明
回忆之前所学的知识，我们建议变量在头文件中声明，在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。

定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。

含有函数声明的头文件应该被包含到定义函数的源文件中。

### 6.1.3 分离式编译

随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。例如，可以把6.1节练习的函数存在一个文件里，把使用这些函数的代码存在其他源文件中。为了允许编写程序时按照逻辑关系划分开来，C++语言支持所谓的**分离式编译**。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。

### 编译和链接多个源文件
举个例子，假如fact函数的定义位于一个名为fact.cc的文件中，它的声明位于名为Chapter6.h的头文件中。显然与其他所用用到fact函数的文件一样，fact.cc应该包含Chapter6.h头文件。另外，我们在名为factMain.cc的头文件中创建main函数，main函数将调用fact函数。要生成**可执行文件**，必须告诉编译器我么我们用到的代码在哪里。对于上述几个文件来说，编译的过程如下所示：
```
$ CC factMain.cc fact.cc # generates factMain.exe or a.out
$ CC factMain.cc fact.cc -o main # generates factMain.exe or a.out
```
其中，CC是编译器的名字，$是系统提示符，#后面是命令行下的注释语句。接下来运行可执行文件，就会执行我们定义的mai函数。

如果我们修改了其中一个源文件，那么只需重新编译那个改动了的文件。大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj(Windows)或.o(UNIX)的文件，后缀名的含义是该文件包含对象代码(object code)。

接下来编译器负责把对象文件链接在一起形成可执行文件。在我们的系统中，编译过程如下所示：
```
$ CC -c factMain.cc # generates factMain.o
$ CC -c fact.cc # generates fact.o
$ CC factMain.o fact.o # generates factMain.exe or a.out
$ CC factMain.o fact.o -o main # generates main or main.exe
```
你可以仔细阅读编译器的用户手册，弄清楚由多个文件组成的程序是如何编译并执行的。

